@page
<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø³ÛŒØ³ØªÙ… Ù†Ø¸Ø§Ø±Øª Ú©Ø§Ø±Ø®Ø§Ù†Ù‡ Ù‡ÙˆØ´Ù…Ù†Ø¯ (Ù†Ø³Ø®Ù‡ Ø¬Ø¯ÛŒØ¯)</title>
    <link rel="stylesheet" href="/css/dashboard.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="main-content">
        <div class="header">
            <h1>ğŸ­ Ø³ÛŒØ³ØªÙ… Ù†Ø¸Ø§Ø±Øª Ú©Ø§Ø±Ø®Ø§Ù†Ù‡ Ù‡ÙˆØ´Ù…Ù†Ø¯</h1>
            <div id="lastUpdate"><span id="timestamp">â° Ø¯Ø± Ø­Ø§Ù„ Ø§ØªØµØ§Ù„...</span></div>
        </div>

        <div class="container">
            <!-- Warning Lights Section -->
            <div class="warning-lights">
                <div class="warning-light">
                    <div class="light-indicator off" id="warningLight"></div>
                    <div class="light-label">ğŸ’¡ Ú†Ø±Ø§Øº Ù‡Ø´Ø¯Ø§Ø± Ø¹Ù…ÙˆÙ…ÛŒ</div>
                    <div class="warning-messages" id="warningMessages"><div>Ø¨Ø¯ÙˆÙ† Ù‡Ø´Ø¯Ø§Ø±</div></div>
                </div>
                <div class="warning-light">
                    <div class="light-indicator off" id="alarmLight"></div>
                    <div class="light-label">ğŸš¨ Ø¢Ú˜ÛŒØ± Ùˆ Ú†Ø±Ø§Øº Ø®Ø·Ø± Ø§ØµÙ„ÛŒ</div>
                    <div class="alarm-messages" id="alarmMessages"><div>ÙˆØ¶Ø¹ÛŒØª Ø¹Ø§Ø¯ÛŒ</div></div>
                </div>
            </div>

            <!-- Dashboard Grid -->
            <div class="card" data-category="temperature">
                <div class="card-header"><div class="card-icon">ğŸŒ¡ï¸</div><div class="card-title">Ø¯Ù…Ø§ Ùˆ Ù…Ø­ÛŒØ· Ø²ÛŒØ³Øª</div></div>
                <div class="sensor-grid" id="temperatureGrid"></div>
                <div class="chart-container"><canvas id="temperatureChart"></canvas></div>
            </div>

            <div class="card" data-category="safety">
                <div class="card-header"><div class="card-icon">âš ï¸</div><div class="card-title">Ø³Ù†Ø³ÙˆØ±Ù‡Ø§ÛŒ Ø§ÛŒÙ…Ù†ÛŒ</div></div>
                <div class="sensor-grid" id="safetyGrid"></div>
                <div class="chart-container gauge-container" id="safetyGaugeContainer"></div>
            </div>

            <div class="card" data-category="production">
                <div class="card-header"><div class="card-icon">ğŸ­</div><div class="card-title">Ø®Ø· ØªÙˆÙ„ÛŒØ¯</div></div>
                <div class="sensor-grid" id="productionGrid"></div>
                <div class="chart-container"><canvas id="productionChart"></canvas></div>
            </div>

            <div class="card" data-category="electrical">
                <div class="card-header"><div class="card-icon">âš¡</div><div class="card-title">Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ù‚ÛŒ</div></div>
                <div class="sensor-grid" id="electricalGrid"></div>
                <div class="chart-container"><canvas id="electricalChart"></canvas></div>
            </div>

            <div class="card factory-layout">
                <div class="card-header"><div class="card-icon">ğŸ—ï¸</div><div class="card-title">Ù†Ù‚Ø´Ù‡ Ú©Ø§Ø±Ø®Ø§Ù†Ù‡</div></div>
                <div class="layout-grid" id="factoryLayout"></div>
            </div>

            <div class="timestamp" id="fullTimestamp"></div>
        </div>
    </div>

    <script>
        // --- SCRIPT START ---

        let connection;
        let charts = {};
        let sensorData = {};
        let sensorLocations = [];

        document.addEventListener('DOMContentLoaded', function() {
            initializeSignalR();
            connection.onclose(async () => {
                await connection.start();
            });
            loadSensorLocations();
            loadCurrentData();
            initializeCharts();
        });

        async function initializeSignalR() { /* ... unchanged ... */ }
        async function loadSensorLocations() { /* ... unchanged ... */ }
        async function loadCurrentData() { /* ... unchanged ... */ }
        function updateDashboard(data) { /* ... unchanged ... */ }
        function updateSensorGrids() { /* ... unchanged ... */ }
        function getStatusInfo(sensor, value) { /* ... unchanged ... */ }
        function createSensorElement(sensor, value, elementId) { /* ... unchanged ... */ }
        function getSensorValue(sensorKey) { /* ... unchanged ... */ }
        function convertToCamelCase(str) { /* ... unchanged ... */ }
        function convertToPascalCase(str) { /* ... unchanged ... */ }
        function updateWarningLights() { /* ... unchanged ... */ }
        function createFactoryLayout() { /* ... unchanged ... */ }
        function updateTimestamp() { /* ... unchanged ... */ }

        // --- MODIFIED & NEW CHART FUNCTIONS ---

        /**
         * Returns a new, high-visibility options object for Chart.js instances.
         */
        function getChartOptions(title, isRadar = false) {
            const fontColor = 'var(--text-color)';
            const gridColor = 'rgba(236, 240, 241, 0.2)';

            let scaleOptions = {
                x: {
                    ticks: { font: { family: 'Vazirmatn', size: 14 }, color: fontColor },
                    grid: { color: gridColor }
                },
                y: {
                    ticks: { font: { family: 'Vazirmatn', size: 14 }, color: fontColor },
                    grid: { color: gridColor }
                }
            };

            if (isRadar) {
                scaleOptions = {
                    r: {
                        pointLabels: { color: fontColor, font: { family: 'Vazirmatn', size: 14 } },
                        grid: { color: gridColor },
                        angleLines: { color: gridColor }
                    }
                };
            }

            return {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: { display: true, text: title, font: { family: 'Vazirmatn', size: 18, weight: 'bold' }, color: fontColor },
                    legend: { labels: { font: { family: 'Vazirmatn', size: 14 }, color: fontColor } }
                },
                scales: scaleOptions
            };
        }

        /**
         * Initializes all charts with new types and improved styling.
         */
        function initializeCharts() {
            // Temperature Chart (Line) - Good for trends
            const tempCtx = document.getElementById('temperatureChart');
            if (tempCtx) {
                charts.temperatureChart = new Chart(tempCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: 'Ø¯Ù…Ø§ÛŒ Ú©ÙˆØ±Ù‡ (Â°C)', data: [], borderColor: 'var(--accent-temp)', backgroundColor: 'rgba(230, 126, 34, 0.3)', tension: 0.4, fill: true }] },
                    options: getChartOptions('Ø±ÙˆÙ†Ø¯ Ø¯Ù…Ø§ÛŒ Ú©ÙˆØ±Ù‡')
                });
            }

            // Production Chart (Horizontal Bar) - Good for comparing discrete values
            const prodCtx = document.getElementById('productionChart');
            if (prodCtx) {
                 charts.productionChart = new Chart(prodCtx, {
                    type: 'bar',
                    data: {
                        labels: [], // Will be populated
                        datasets: [{
                            label: 'Ù…Ù‚Ø§Ø¯ÛŒØ± Ø³Ù†Ø³ÙˆØ±',
                            data: [], // Will be populated
                            backgroundColor: ['#3498db', '#1abc9c', '#2ecc71', '#34495e', '#f1c40f']
                        }]
                    },
                    options: { ...getChartOptions('Ù…Ù‚Ø§Ø¯ÛŒØ± Ø®Ø· ØªÙˆÙ„ÛŒØ¯'), indexAxis: 'y' } // indexAxis:'y' makes it horizontal
                });
            }

            // Electrical Chart (Radar) - Good for system balance
            const electricalCtx = document.getElementById('electricalChart');
            if (electricalCtx) {
                charts.electricalChart = new Chart(electricalCtx, {
                    type: 'radar',
                    data: { labels: ['Ø¬Ø±ÛŒØ§Ù† Ø§ØµÙ„ÛŒ', 'Ù„Ø±Ø²Ø´ Ù…ÙˆØªÙˆØ±', 'ÙˆÙ„ØªØ§Ú˜ ÙˆØ±ÙˆØ¯ÛŒ'], datasets: [{ label: 'Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ù‚ÛŒ', data: [0, 0, 0], borderColor: 'var(--accent-electrical)', backgroundColor: 'rgba(255, 242, 128, 0.5)' }] },
                    options: getChartOptions('ØªØ¹Ø§Ø¯Ù„ Ø³ÛŒØ³ØªÙ… Ø¨Ø±Ù‚', true)
                });
            }
        }

        /**
         * Updates all charts with new data from the API.
         */
        function updateCharts() {
            const now = new Date().toLocaleTimeString('fa-IR');

            // Update Temperature Line Chart
            if (charts.temperatureChart) {
                const chart = charts.temperatureChart;
                chart.data.labels.push(now);
                chart.data.datasets[0].data.push(getSensorValue('Furnace_Temp'));
                if (chart.data.labels.length > 15) {
                    chart.data.labels.shift();
                    chart.data.datasets[0].data.shift();
                }
                chart.update();
            }

            // Update Safety Gauge Charts
            updateSafetyGauges();

            // Update Production Horizontal Bar Chart
            if (charts.productionChart) {
                const productionKeys = ['Machine_Sound', 'Conveyor_Dist', 'Coolant_Valve'];
                const labels = productionKeys.map(key => sensorLocations.find(s => s.key === key)?.name || key);
                const data = productionKeys.map(key => getSensorValue(key));

                charts.productionChart.data.labels = labels;
                charts.productionChart.data.datasets[0].data = data;
                charts.productionChart.update();
            }

            // Update Electrical Radar Chart
            if (charts.electricalChart) {
                charts.electricalChart.data.datasets[0].data = [getSensorValue('Main_Current'), getSensorValue('Engine_Vibe'), getSensorValue('Input_Voltage')];
                charts.electricalChart.update();
            }
        }

        /**
         * Creates or updates the individual gauge charts for the safety sensors.
         */
        function updateSafetyGauges() {
            const container = document.getElementById('safetyGaugeContainer');
            if (!container) return;

            const safetySensors = ['Gas_Methane', 'Gas_CO', 'Tank_Pressure'];

            safetySensors.forEach(sensorKey => {
                const sensor = sensorLocations.find(s => s.key === sensorKey);
                if (!sensor) return;

                const value = getSensorValue(sensorKey);
                const max = sensor.maxSafe || 100; // Use maxSafe or a default
                const id = `gauge-${sensorKey}`;
                let gaugeWrapper = document.getElementById(id);

                if (!gaugeWrapper) {
                    // Create the gauge structure if it doesn't exist
                    gaugeWrapper = document.createElement('div');
                    gaugeWrapper.id = id;
                    gaugeWrapper.innerHTML = `
                        <div class="gauge">
                            <canvas id="canvas-${id}"></canvas>
                            <div class="gauge-text" id="text-${id}"></div>
                        </div>
                        <div class="gauge-label">${sensor.name}</div>
                    `;
                    container.appendChild(gaugeWrapper);

                    const ctx = document.getElementById(`canvas-${id}`).getContext('2d');
                    charts[id] = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            datasets: [{
                                data: [value, max - value],
                                backgroundColor: [getStatusInfo(sensor, value).statusClass === 'danger' ? 'var(--danger-color)' : 'var(--warning-color)', 'rgba(255, 255, 255, 0.1)'],
                                borderColor: 'var(--card-background-color)',
                                borderWidth: 2,
                                circumference: 180, // Half circle
                                rotation: 270,      // Start at the bottom
                            }]
                        },
                        options: { responsive: true, cutout: '80%', plugins: { tooltip: { enabled: false } } }
                    });
                }

                // Update existing gauge
                const chart = charts[id];
                const text = document.getElementById(`text-${id}`);
                chart.data.datasets[0].data = [value, Math.max(0, max - value)]; // Ensure second value isn't negative
                chart.data.datasets[0].backgroundColor[0] = getStatusInfo(sensor, value).statusClass === 'danger' ? 'var(--danger-color)' : 'var(--warning-color)';
                text.textContent = value;
                chart.update();
            });
        }



        // --- UNCHANGED HELPER FUNCTIONS ---
        // (Copied here to make the script block complete)
        async function initializeSignalR() { connection = new signalR.HubConnectionBuilder().withUrl("/sensorhub").build(); connection.on("SensorDataUpdate", updateDashboard); try { await connection.start(); console.log("SignalR Connected"); } catch (err) { console.error("SignalR Connection Error: ", err); } }
        async function loadSensorLocations() { try { const response = await fetch('/api/sensor/locations'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const result = await response.json(); if (result.success) { sensorLocations = result.data; createFactoryLayout(); } } catch (error) { console.error('Error loading sensor locations:', error); } }
        async function loadCurrentData() { try { const response = await fetch('/api/sensor/current'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const result = await response.json(); if (result.success) { updateDashboard(result.data); } } catch (error) { console.error('Error loading current data:', error); } }
        function updateDashboard(data) { sensorData = data; updateSensorGrids(); updateWarningLights(); updateCharts(); updateTimestamp(); }
        function updateSensorGrids() { const categories = { temperature: ['Furnace_Temp', 'Env_Humid', 'Light_Level'], safety: ['Gas_Methane', 'Gas_CO', 'Tank_Pressure', 'Flame_Status', 'Water_Leak'], production: ['Machine_Sound', 'Conveyor_Dist', 'Gate_Status', 'E_Stop_Button', 'Coolant_Valve'], electrical: ['Main_Current', 'Engine_Vibe', 'Input_Voltage'] }; Object.keys(categories).forEach(category => { const grid = document.getElementById(category + 'Grid'); if (grid) { categories[category].forEach(sensorKey => { const sensor = sensorLocations.find(s => s.key === sensorKey); if (sensor) { const value = getSensorValue(sensorKey); const sensorId = `sensor-${sensorKey}`; let sensorElement = document.getElementById(sensorId); if (!sensorElement) { sensorElement = createSensorElement(sensor, value, sensorId); grid.appendChild(sensorElement); } else { const valueDiv = sensorElement.querySelector('.sensor-value'); const unitDiv = sensorElement.querySelector('.sensor-unit'); if (valueDiv.textContent != value) { const statusInfo = getStatusInfo(sensor, value); valueDiv.textContent = value; valueDiv.className = `sensor-value ${statusInfo.statusClass}`; unitDiv.textContent = `${sensor.unit} ${statusInfo.status}`; sensorElement.classList.remove('value-update-normal', 'value-update-warning', 'value-update-danger'); void sensorElement.offsetWidth; sensorElement.classList.add(statusInfo.animationClass); } } } }); } }); }
        function getStatusInfo(sensor, value) { if (sensor.maxSafe !== null && value > sensor.maxSafe) { return { status: 'âš ï¸', statusClass: 'danger', animationClass: 'value-update-danger'}; } else if (sensor.minSafe !== null && value < sensor.minSafe) { return { status: 'âš ï¸', statusClass: 'warning', animationClass: 'value-update-warning'}; } else { return { status: 'âœ…', statusClass: 'normal', animationClass: 'value-update-normal'}; } }
        function createSensorElement(sensor, value, elementId) { const div = document.createElement('div'); div.className = 'sensor-item'; div.id = elementId; div.style.setProperty('--sensor-color', sensor.color || '#3498db'); const statusInfo = getStatusInfo(sensor, value); div.innerHTML = `<div style="font-size: 1.5rem;">${sensor.icon}</div><div class="sensor-value ${statusInfo.statusClass}">${value}</div><div class="sensor-name">${sensor.name}</div><div class="sensor-unit">${sensor.unit} ${statusInfo.status}</div>`; return div; }
        function getSensorValue(sensorKey) { const camelCaseKey = sensorKey.charAt(0).toLowerCase() + sensorKey.slice(1); const possibleNames = [camelCaseKey, sensorKey, convertToCamelCase(sensorKey), sensorKey.toLowerCase(), sensorKey.replace(/_/g, ''), sensorKey.toLowerCase().replace(/_/g, ''), convertToPascalCase(sensorKey)]; for (const name of possibleNames) { if (sensorData.hasOwnProperty(name) && sensorData[name] !== null) { return sensorData[name]; } } return 0; }
        function convertToCamelCase(str) { return str.toLowerCase().replace(/_([a-z])/g, (match, letter) => letter.toUpperCase()); }
        function convertToPascalCase(str) { return str.toLowerCase().replace(/_([a-z])/g, (match, letter) => letter.toUpperCase()).replace(/^[a-z]/, match => match.toUpperCase()); }
        function updateWarningLights() { const warningLight = document.getElementById('warningLight'); const alarmLight = document.getElementById('alarmLight'); const warningMessages = document.getElementById('warningMessages'); const alarmMessages = document.getElementById('alarmMessages'); const activeWarnings = sensorData.activeWarnings || []; const activeAlarms = sensorData.activeAlarms || []; const warningLED = getSensorValue('Warning_LED') || activeWarnings.length > 0; const alarmSystem = getSensorValue('Alarm_System') || activeAlarms.length > 0; if (warningLED) { warningLight.className = 'light-indicator warning-on'; warningMessages.innerHTML = activeWarnings.map(msg => `<div class="message-item">${msg}</div>`).join('') || '<div class="message-item">Ù‡Ø´Ø¯Ø§Ø± ÙØ¹Ø§Ù„</div>'; } else { warningLight.className = 'light-indicator off'; warningMessages.innerHTML = '<div>Ø¨Ø¯ÙˆÙ† Ù‡Ø´Ø¯Ø§Ø±</div>'; } if (alarmSystem) { alarmLight.className = 'light-indicator alarm-on'; alarmMessages.innerHTML = activeAlarms.map(msg => `<div class="message-item">${msg}</div>`).join('') || '<div class="message-item">Ø¢Ù„Ø§Ø±Ù… ÙØ¹Ø§Ù„</div>'; } else { alarmLight.className = 'light-indicator off'; alarmMessages.innerHTML = '<div>ÙˆØ¶Ø¹ÛŒØª Ø¹Ø§Ø¯ÛŒ</div>'; } }
        function createFactoryLayout() { const layout = document.getElementById('factoryLayout'); if (!layout || sensorLocations.length === 0) return; const areas = {}; sensorLocations.forEach(sensor => { if (!areas[sensor.area]) areas[sensor.area] = []; areas[sensor.area].push(sensor); }); layout.innerHTML = ''; for (const areaName in areas) { const areaDiv = document.createElement('div'); areaDiv.className = 'area-section'; areaDiv.innerHTML = `<div class="area-title">${areaName}</div><div class="area-sensors">${areas[areaName].map(s => `<div class="area-sensor" style="--sensor-color: ${s.color || '#3498db'};"><span>${s.icon}</span><span>${s.name}</span></div>`).join('')}</div>`; layout.appendChild(areaDiv); } }
        function updateTimestamp() { const now = new Date(); const persianTime = now.toLocaleString('fa-IR'); document.getElementById('timestamp').textContent = `â° Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ: ${persianTime}`; document.getElementById('fullTimestamp').textContent = `Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ: ${persianTime}`; }
        
    </script>
</body>
</html>